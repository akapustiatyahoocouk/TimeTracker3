using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace TimeTracker3.Util
{
    /// <summary>
    ///     A dictionary with weak values.
    ///     IMPORTANT: Cannot contain nulls as keys or values.
    /// </summary>
    /// <typeparam name="TKey">
    ///     The type of the dictionary keys.
    /// </typeparam>
    /// <typeparam name="TValue">
    ///     The type of the dictionary values.
    /// </typeparam>
    public class WeakValueDictionary<TKey, TValue> : IDictionary<TKey, TValue>
    where TValue : class
    {
        //////////
        //  Construction - generated by compiler

        //////////
        //  IDictionary<TKey,TValue>
        public ICollection<TKey> Keys => _Dict.Keys;

        public ICollection<TValue> Values
        {
            get
            {
                List<TValue> values = new List<TValue>();
                foreach (KeyValuePair<TKey, WeakReference<TValue>> kvp in _Dict)
                {
                    if (kvp.Value.TryGetTarget(out var value))
                    {
                        values.Add(value);
                    }
                }
                return values;
            }
        }

        public bool ContainsKey(TKey key)
        {
            Debug.Assert(key != null);

            AutoCleanup(1);
            return _Dict.TryGetValue(key, out var valueRef) && valueRef.TryGetTarget(out _);
        }

        public void Add(TKey key, TValue value)
        {
            Debug.Assert(key != null);
            Debug.Assert(value != null);

            AutoCleanup(2);
            if (_Dict.TryGetValue(key, out var wr))
            {
                if (wr.TryGetTarget(out _))
                {
                    throw new ArgumentException("An element with the same key already exists in this WeakValueDictionary");
                }
                wr.SetTarget(value);
            }
            else
            {
                _Dict.Add(key, new WeakReference<TValue>(value));
            }
        }

        public bool Remove(TKey key)
        {
            Debug.Assert(key != null);

            AutoCleanup(1);
            if (!_Dict.TryGetValue(key, out var wr))
            {
                return false;
            }
            _Dict.Remove(key);
            return wr.TryGetTarget(out _);
        }

        public bool TryGetValue(TKey key, out TValue value)
        {
            Debug.Assert(key != null); 
            
            AutoCleanup(1);
            bool result;
            if (_Dict.TryGetValue(key, out var wr))
            {
                result = wr.TryGetTarget(out value);
            }
            else
            {
                value = null;
                result = false;
            }
            return result;
        }

        public TValue this[TKey key]
        {
            get
            {
                Debug.Assert(key != null);
                
                if (_Dict.TryGetValue(key, out var wr))
                {
                    if (wr.TryGetTarget(out var value))
                    {
                        return value;
                    }  //  OOPS! The value has been discarded!
                    _Dict.Remove(key);
                    return null;
                }  //  OOPS! Key not in dictionary!
                return null;
            }
            set
            {
                Debug.Assert(key != null);
                Debug.Assert(value  != null);

                _Dict[key] = new WeakReference<TValue>(value);
            }
        }

        //////////
        //  ICollection<KeyValuePair<TKey,TValue>> Members
        public void Add(KeyValuePair<TKey, TValue> item)
        {
            Debug.Assert(item.Key != null);
            Debug.Assert(item.Value != null);

            Add(item.Key, item.Value);
        }

        public void Clear()
        {
            _Dict.Clear();
            _Version = _CleanVersion = 0;
            _CleanGeneration = 0;
        }

        public bool Contains(KeyValuePair<TKey, TValue> item)
        {
            Debug.Assert(item.Key != null);
            Debug.Assert(item.Value != null);

            throw new NotImplementedException();
        }

        public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
        {
            Debug.Assert(array != null);

            throw new NotImplementedException();
        }

        // THIS VALUE MAY BE WRONG (i.e. it may be higher than the number of 
        // items you get from the iterator).
        public int Count => _Dict.Count;

        public bool IsReadOnly => false;

        public bool Remove(KeyValuePair<TKey, TValue> item)
        {
            Debug.Assert(item.Key != null);
            Debug.Assert(item.Value != null);

            throw new NotImplementedException();
        }

        //////////
        //  IEnumerable<KeyValuePair<TKey,TValue>> Members
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { return GetEnumerator(); }

        public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
        {
            int nullCount = 0;

            foreach (KeyValuePair<TKey, WeakReference<TValue>> kvp in _Dict)
            {
                if (kvp.Value.TryGetTarget(out var target))
                {
                    yield return new KeyValuePair<TKey, TValue>(kvp.Key, target);
                }
                else
                {
                    nullCount++;
                }
            }

            if (nullCount > _Dict.Count / 4)
            {
                Cleanup();
            }
        }

        //////////
        //  Implementation
        private Dictionary<TKey, WeakReference<TValue>> _Dict = new Dictionary<TKey, WeakReference<TValue>>();
        private int _Version, _CleanVersion;
        private int _CleanGeneration;
        private const int _MinRehashInterval = 500;

        //  Helpers
        private void Cleanup()
        {   //  Remove all pairs whose value is nullified.
            foreach (TKey key in (from kvp in _Dict where !kvp.Value.TryGetTarget(out _) select kvp.Key))
            {
                _Dict.Remove(key);
            }
        }

        private void AutoCleanup(int incVersion)
        {
            _Version += incVersion;

            //  Cleanup the table every so often--less often for larger tables.
            long delta = _Version - _CleanVersion;
            if (delta > _MinRehashInterval + _Dict.Count)
            {   //  A cleanup will be fruitless unless a GC has happened in
                //  the meantime. WeakReferences can become zero only during
                //  the GC.
                int curGeneration = GC.CollectionCount(0);
                if (_CleanGeneration != curGeneration)
                {
                    _CleanGeneration = curGeneration;
                    Cleanup();
                    _CleanVersion = _Version;
                }
                else
                {
                    _CleanVersion += _MinRehashInterval;     // Wait a little while longer
                }
            }
        }
    }
}

